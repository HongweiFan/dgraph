- name: "Auth with deep get query."
  gqlquery: |
    query {
      getProject(projID: "0x123") {
        projID
        columns {
          name
          colID
        }
      }
    }
  dgquery: |-
    query {
      getProject(func: uid(Project2)) @filter((uid(Project3) AND type(Project))) {
        projID : uid
        columns : Project.columns @filter(uid(Column1)) {
          name : Column.name
          colID : uid
        }
      }
      Project2 as var(func: uid(0x123))
      Project3 as var(func: uid(Project2)) @cascade {
        roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
          assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      Column1 as var(func: type(Column)) @cascade {
        inProject : Column.inProject {
          roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
            assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "Auth with top level filter : query, no filter"
  gqlquery: |
    query {
      queryUserSecret {
        id
        ownedBy
      }
    }
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecret1)) @filter(uid(UserSecret2)) {
        id : uid
        ownedBy : UserSecret.ownedBy
      }
      UserSecret1 as var(func: type(UserSecret))
      UserSecret2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with top level filter : get"
  gqlquery: |
    query {
      getUserSecret(id: "0x123") {
        id
        ownedBy
      }
    }
  dgquery: |-
    query {
      getUserSecret(func: uid(UserSecret1)) @filter((uid(UserSecret2) AND type(UserSecret))) {
        id : uid
        ownedBy : UserSecret.ownedBy
      }
      UserSecret1 as var(func: uid(0x123))
      UserSecret2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with top level filter : query and filter"
  gqlquery: |
    query {
      queryUserSecret(filter: { ownedBy: { eq: "user2" }}) {
        id
        ownedBy
      }
    }
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecret1)) @filter(uid(UserSecret2)) {
        id : uid
        ownedBy : UserSecret.ownedBy
      }
      UserSecret1 as var(func: type(UserSecret)) @filter(eq(UserSecret.ownedBy, "user2"))
      UserSecret2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Deep RBAC rules true"
  gqlquery: |
    query {
      queryUser {
        issues {
          id
        }
      }
    }
  role: "ADMIN"
  dgquery: |-
      query {
        queryUser(func: type(User)) {
          issues : User.issues @filter(uid(Issue1)) {
            id : uid
          }
          dgraph.uid : uid
        }
        Issue1 as var(func: type(Issue)) @cascade {
          owner : Issue.owner @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
      }

- name: "Deep RBAC rules false"
  gqlquery: |
    query {
      queryUser {
        username
        issues {
          id
        }
      }
    }
  role: "USER"
  dgquery: |-
      query {
        queryUser(func: type(User)) {
          username : User.username
          dgraph.uid : uid
        }
      }


- name: "Auth with top level AND rbac true"
  gqlquery: |
    query {
      queryIssue {
        msg
      }
    }
  role: "ADMIN"
  dgquery: |-
     query {
       queryIssue(func: uid(Issue1)) @filter(uid(Issue2)) {
         msg : Issue.msg
         dgraph.uid : uid
       }
       Issue1 as var(func: type(Issue))
       Issue2 as var(func: uid(Issue1)) @cascade {
         owner : Issue.owner @filter(eq(User.username, "user1"))
         dgraph.uid : uid
       }
     }

- name: "Auth with complex rbac rules, true"
  gqlquery: |
    query {
      queryComplexLog {
        logs
      }
    }
  role: "ADMIN"
  dgquery: |-
    query {
      queryComplexLog(func: type(ComplexLog)) {
        logs : ComplexLog.logs
        dgraph.uid : uid
      }
    }

- name: "Auth with complex rbac rules, false"
  gqlquery: |
    query {
      queryComplexLog {
        logs
      }
    }
  role: "USER"
  dgquery: |-
    query {
      queryComplexLog()
    }

- name: "Auth with top level rbac true"
  gqlquery: |
    query {
      queryLog {
        logs
      }
    }
  role: "ADMIN"
  dgquery: |-
    query {
      queryLog(func: type(Log)) {
        logs : Log.logs
        dgraph.uid : uid
      }
    }

- name: "Auth with top level rbac false"
  gqlquery: |
    query {
      queryLog {
        logs
      }
    }
  role: "USER"
  dgquery: |-
     query {
       queryLog()
     }

- name: "Auth with top level AND rbac false"
  gqlquery: |
    query {
      queryIssue {
        msg
      }
    }
  role: "USER"
  dgquery: |-
     query {
       queryIssue()
     }


- name: "Auth with top level OR rbac true"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  role: "ADMIN"
  dgquery: |-
     query {
       queryProject(func: type(Project)) {
         name : Project.name
         dgraph.uid : uid
       }
     }

- name: "Query with missing jwt variables"
  gqlquery: |
    query {
      queryGroup {
        id
      }
    }
  dgquery: |-
    query {
      queryGroup(func: uid(Group1)) @filter((uid(Group2) OR uid(Group3))) {
        id : uid
      }
      Group1 as var(func: type(Group))
      Group2 as var(func: uid(Group1)) @cascade {
        users : Group.users @filter(eq(User.username, "user1"))
        dgraph.uid : uid
      }
      Group3 as var(func: uid(Group1)) @cascade {
        createdBy : Group.createdBy @filter(eq(User.username, "user1"))
        dgraph.uid : uid
      }
    }

- name: "Auth with top level OR rbac false"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  role: "USER"
  dgquery: |-
    query {
      queryProject(func: uid(Project1)) @filter(uid(Project2)) {
        name : Project.name
        dgraph.uid : uid
      }
      Project1 as var(func: type(Project))
      Project2 as var(func: uid(Project1)) @cascade {
        roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
          assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "Auth with top level filter : query, filter and order"
  gqlquery: |
    query {
      queryUserSecret(filter: { ownedBy: { eq: "user2" }}, order: {asc: aSecret}, first: 1) {
        id
        ownedBy
      }
    }
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecret1), orderasc: UserSecret.aSecret, first: 1) @filter(uid(UserSecret2)) {
        id : uid
        ownedBy : UserSecret.ownedBy
      }
      UserSecret1 as var(func: type(UserSecret)) @filter(eq(UserSecret.ownedBy, "user2"))
      UserSecret2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with deep filter : query top-level"
  gqlquery: |
    query {
      queryTicket {
        id
        title
      }
    }
  dgquery: |-
    query {
      queryTicket(func: uid(Ticket1)) @filter(uid(Ticket2)) {
        id : uid
        title : Ticket.title
      }
      Ticket1 as var(func: type(Ticket))
      Ticket2 as var(func: uid(Ticket1)) @cascade {
        onColumn : Ticket.onColumn {
          inProject : Column.inProject {
            roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
              dgraph.uid : uid
            }
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "Auth with deep filter : query deep requires auth"
  gqlquery: |
    query {
      queryUser {
        username
        tickets {
          id
          title 
        }
      }
    }
  dgquery: |-
    query {
      queryUser(func: type(User)) {
        username : User.username
        tickets : User.tickets @filter(uid(Ticket1)) {
          id : uid
          title : Ticket.title
        }
        dgraph.uid : uid
      }
      Ticket1 as var(func: type(Ticket)) @cascade {
        onColumn : Ticket.onColumn {
          inProject : Column.inProject {
            roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
              dgraph.uid : uid
            }
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "Auth with deep filter and field filter : query deep requires auth"
  gqlquery: |
    query {
      queryUser {
        username
        tickets(filter: { title: { anyofterms: "graphql" } }) {
          id
          title 
        }
      }
    }
  dgquery: |-
    query {
      queryUser(func: type(User)) {
        username : User.username
        tickets : User.tickets @filter((anyofterms(Ticket.title, "graphql") AND uid(Ticket1))) {
          id : uid
          title : Ticket.title
        }
        dgraph.uid : uid
      }
      Ticket1 as var(func: type(Ticket)) @cascade {
        onColumn : Ticket.onColumn {
          inProject : Column.inProject {
            roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
              dgraph.uid : uid
            }
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "Auth deep query - 0 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "A. N. Author" } },  order: { asc: content }, first: 10, offset: 10)  {
        content
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot)) {
        content : Movie.content
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie1), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth2)) AND (uid(MovieAuth3) OR uid(MovieAuth4))))
      Movie1 as var(func: type(Movie)) @filter(eq(Movie.content, "A. N. Author"))
      MovieAuth2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth3 as var(func: uid(Movie1)) @cascade {
        regionsAvailable : Movie.regionsAvailable {
          users : Region.users @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieAuth4 as var(func: uid(Movie1)) @cascade {
        regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
        dgraph.uid : uid
      }
    }

- name: "Auth deep query - 1 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "MovieXYZ" } },  order: { asc: content }, first: 10, offset: 10)  {
        content
        regionsAvailable(filter: { name: { eq: "Region123" } },  order: { asc: name }, first: 10, offset: 10) {
          name
          global
        }
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot)) {
        content : Movie.content
        regionsAvailable : Movie.regionsAvailable @filter(uid(Region2)) {
          name : Region.name
          global : Region.global
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie3), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth4)) AND (uid(MovieAuth5) OR uid(MovieAuth6))))
      Movie3 as var(func: type(Movie)) @filter(eq(Movie.content, "MovieXYZ"))
      MovieAuth4 as var(func: uid(Movie3)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth5 as var(func: uid(Movie3)) @cascade {
        regionsAvailable : Movie.regionsAvailable {
          users : Region.users @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieAuth6 as var(func: uid(Movie3)) @cascade {
        regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
        dgraph.uid : uid
      }
      var(func: uid(MovieRoot)) {
        Region1 as regionsAvailable
      }
      Region2 as var(func: uid(Region1), orderasc: Region.name, first: 10, offset: 10) @filter(eq(Region.name, "Region123"))
    }

- name: "Auth deep query - 3 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "MovieXYZ" } },  order: { asc: content }, first: 10, offset: 10)  {
        content
        regionsAvailable(filter: { name: { eq: "Region123" } },  order: { asc: name }, first: 10, offset: 10) {
          name
          global
          users(filter: { username: { eq: "User321" } },  order: { asc: username }, first: 10, offset: 10)  {
            username
            age
            isPublic
            secrets(filter: { aSecret: { allofterms : "Secret132" } },  order: { asc: aSecret }, first: 10, offset: 10)  {
              aSecret
              ownedBy
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot)) {
        content : Movie.content
        regionsAvailable : Movie.regionsAvailable @filter(uid(Region7)) {
          name : Region.name
          global : Region.global
          users : Region.users @filter(uid(User6)) {
            username : User.username
            age : User.age
            isPublic : User.isPublic
            secrets : User.secrets @filter(uid(UserSecret5)) {
              aSecret : UserSecret.aSecret
              ownedBy : UserSecret.ownedBy
              dgraph.uid : uid
            }
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie8), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth9)) AND (uid(MovieAuth10) OR uid(MovieAuth11))))
      Movie8 as var(func: type(Movie)) @filter(eq(Movie.content, "MovieXYZ"))
      MovieAuth9 as var(func: uid(Movie8)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth10 as var(func: uid(Movie8)) @cascade {
        regionsAvailable : Movie.regionsAvailable {
          users : Region.users @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieAuth11 as var(func: uid(Movie8)) @cascade {
        regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
        dgraph.uid : uid
      }
      var(func: uid(MovieRoot)) {
        Region1 as regionsAvailable
      }
      Region7 as var(func: uid(Region1), orderasc: Region.name, first: 10, offset: 10) @filter(eq(Region.name, "Region123"))
      var(func: uid(Region1)) {
        User2 as users
      }
      User6 as var(func: uid(User2), orderasc: User.username, first: 10, offset: 10) @filter(eq(User.username, "User321"))
      var(func: uid(User2)) {
        UserSecret3 as secrets
      }
      UserSecret5 as var(func: uid(UserSecret3), orderasc: UserSecret.aSecret, first: 10, offset: 10) @filter((allofterms(UserSecret.aSecret, "Secret132") AND uid(UserSecretAuth4)))
      UserSecretAuth4 as var(func: uid(UserSecret3)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with complex filter"
  gqlquery: |
    query {
      queryMovie {
        content
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(Movie1)) @filter((NOT (uid(Movie2)) AND (uid(Movie3) OR uid(Movie4)))) {
        content : Movie.content
        dgraph.uid : uid
      }
      Movie1 as var(func: type(Movie))
      Movie2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      Movie3 as var(func: uid(Movie1)) @cascade {
        regionsAvailable : Movie.regionsAvailable {
          users : Region.users @filter(eq(User.username, "user1"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      Movie4 as var(func: uid(Movie1)) @cascade {
        regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
        dgraph.uid : uid
      }
    }

- name: "Query with missing variable - top level"
  gqlquery: |
    query {
      queryUserSecret {
        id
      }
    }
  dgquery: |-
    query {
      queryUserSecret()
    }

- name:  "Get with top level RBAC false"
  gqlquery: |
    query {
      getLog(id: "0x123") {
        id
      }
    }
  dgquery: |-
    query {
      getLog()
    }

- name: "Query with missing variable - deep query"
  gqlquery: |
    query {
      queryUser {
        username
        tickets {
          id
          title
        }
      }
    }
  dgquery: |-
    query {
      queryUser(func: type(User)) {
        username : User.username
        dgraph.uid : uid
      }
    }

- name: "Query with missing variable - partial jwt token"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  role: "ADMIN"
  dgquery: |-
    query {
      queryProject(func: type(Project)) {
        name : Project.name
        dgraph.uid : uid
      }
    }

- name: "Query with missing jwt token - type without auth directive"
  gqlquery: |
    query {
      queryRole {
        permission
      }
    }
  dgquery: |-
    query {
      queryRole(func: type(Role)) {
        permission : Role.permission
        dgraph.uid : uid
      }
    }

- name: "Query with missing jwt token - type with auth directive"
  gqlquery: |
    query {
      queryMovie {
        content
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(Movie1)) @filter((NOT (uid(Movie2)) AND uid(Movie3))) {
        content : Movie.content
        dgraph.uid : uid
      }
      Movie1 as var(func: type(Movie))
      Movie2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      Movie3 as var(func: uid(Movie1)) @cascade {
        regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
        dgraph.uid : uid
      }
    }

- name: "Query with missing jwt token - type with empty auth directive"
  gqlquery: |
    query {
      queryReview {
        comment
      }
    }
  dgquery: |-
    query {
      queryReview(func: type(Review)) {
        comment : Review.comment
        dgraph.uid : uid
      }
    }